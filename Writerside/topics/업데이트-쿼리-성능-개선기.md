# 업데이트 쿼리 성능 개선기

## 문제 상황

고객사 서버(B2B)에서 이미지 업로드 상태 필드를 업데이트하는 스케줄러 로직으로 인해 과도한 CPU 점유가 다른 프로세스에 영향을 주는 상황이 발생했다.

스케줄러를 통해 5분에 한 번씩 업로드가 끝난 이미지를 조회하고 문서 테이블과 조인하여 업데이트 쿼리를 날리는 방식으로 동작하고 있다.

로그를 확인하니 이 스케줄러가 실행되는 동안 CPU 점유율이 1200%까지 올라가는 현상이 발생한 것을 확인할 수 있었다.

## 문제 원인

이 문제에 대한 원인을 사양적인 문제와 쿼리 자체의 문제로 나눌 수 있었다.

사양적인 관점으로 보면 이미지 업로드 상태 필드를 사용하지 않는 방법이 있다.

상태 필드의 사용처가 이미지 업로드가 다 되지 않았다면, 사용자가 이미지를 보다가 안 올라온 이미지는 볼 수 없을 것이고 이를 방지하기 위해 필드를 사용하고 있다. 

따라서 상태 필드가 필요한 이유는 이미지 업로드가 전부 완료된 이후에 사용자에게 이미지를 보여주기 위함이다.

하지만 이미지가 올라간 부분까지만 보여주고 나머지는 보여주지 않는 방법도 있다고 생각했다.

대부분의 경우 이미지가 올라가는 속도가 빠르기 때문에 사용자가 이미지를 보다가 업로드가 완료되지 않은 이미지를 보게 될 확률은 낮고 많은 이미지를 올리는 경우에는 
사용자가 어느정도 감내를 할 수 있을 것이라고 생각했다.

그리고 스케줄러의 주기가 5분이기 때문에 이미지의 업로드 속도와 상관없이 사용자가 이미지를 보기 위해서는 최소 5분을 기다려야 하기 때문에 이 필드를 사용하지 않는 방법도 괜찮을 것이라 생각했다.

이 방법의 장점과 단점은 다음과 같다.

- 장점
  - 업데이트 스케줄러가 필요 없어지므로 부하를 주는 원인 자체가 사라진다.
  - 이미지 업로드 속도와 상관없이 스케줄러의 주기만큼 기다려야 하는 문제도 부가적으로 해결된다.
- 단점
  - 사용자가 업로드된 이미지를 보다가 업로드가 완료되지 않은 이미지를 보게 될 수 있다.
  - UI 작업과 고객사 패치도 필요하다.

기술적인 관점으로 보면 업데이트 쿼리 자체의 성능과 짧은 스케줄링에 의한 지속적인 부하가 문제였다.

문제가 되는 쿼리를 비슷하게 재현해보면 다음과 같다.

```sql
UPDATE document_log
SET upload_status = 'FIN'
WHERE upload_status != 'FIN'
  AND transaction_id IN
      (SELECT transaction_id
       FROM (SELECT transaction_id, count(trans_id) as trans_count, file_count
             FROM file_log
             WHERE log_type = 1
               AND file_type = 2
               AND process_time >= '${last_updated_time}'
             GROUP BY trans_id, file_count) AS Z
       WHERE Z.trans_count >= Z.file_count);
```

document_log, file_log라는 규모가 큰 테이블 간의 조인, 데이터가 많은 document_log 테이블의 Update 부하, 쿼리의 인덱스를 제대로 타지 못하는 문제가 있었다.

따라서 업데이트 쿼리 자체의 성능을 개선하는 것보다 업데이트 스케줄링을 제거하고 매번 조회 요청을 날릴 때마다 상태를 조인하는 방식을 생각했다.

이 방법의 장점과 단점은 다음과 같다.

- 장점
  - UI 작업이 필요하지 않다.
  - 사용자는 기능의 변경없이 문제를 해결된다.
- 단점
  - 부하를 주는 원인 자체가 사라진다.
  - 조인에 의해 조회 성능이 느려질 수 있다.

## 문제 해결

팀장님, 사수님과 이 문제에 대해 논의한 결과 이 문제를 해결하기 위해 UI 패치나 사양 변경 같은 리스크는 조금 부담이 된다고 판단했다.

그 방법이 아니더라도 충분히 성능을 개선할 수 있는 조회 요청시 상태를 조인하는 방식을 선택했다.

## 마무리
